---
title: 数据结构复习提点
date: 2025-11-09 12:47:15
tags: 期末考试 复习 数据结构
---

**Warning:** 你已经是一个合格的大学生了，要学会有自我主见和自我意识，遇到不会的或者不懂的准备提问的时候，先学习一下懂得**提问的智慧**

**考试时间：13周周四下午14点到16点**

### 试卷题目类型：

> **解答题**

课后练习的形式，例如输出排序结果

> **算法题**

$3$ 种形式

算法阅读，给定测试数据

书写代码含义，简洁的一句话左右：遍历？深度？

算法填空

> **算法设计（8分） -- 手写代码 写代码体**


1）单链表
2）二叉树

> **特别提示：平时成绩**

### 复习内容：

> **1）时间复杂度/频度： 简化的描述,注意书写形式**

定位书本Page: $13-18$

大部分情况下，单个表达式和语句的运行时间是常数，可认为与问题规模 $n$ 无关，记为 $O(1)$

一般情况下，通过找出执行次数最多的代码段，把它们的运行语句的总次数表示为 $n$ 的函数，就能确定算法的计算复杂度。对于并列循环结构，取各循环结构计算时间的最大值。对于嵌套循环结构，取最内层循环体中语句的执行次数。如果各层循环的次数是相互无关的，可简单采用乘法法则：各层循环的次数相乘

![](https://cdn.luogu.com.cn/upload/image_hosting/wjtag1ts.png)

**例题：**

Q1: 询问下面代码的时间复杂度：

```cpp
    void bubbleSort(int arr[], int n) {
    int i, j, temp;
    for (i = 0; i < n-1; i++) {
        for (j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```

A1: 这个时间复杂度是 $O((n) \times (n-i))$，由于只需要求出它关于 $n$ 的增长率或阶即可。大 $O$ 符号可以简化圆括号内的公式，让其以最简单的形式表达算法的定性行为，因此，此题时间复杂度简化为 $O(n^2)$

**个人认为：需要懂得一些常见的复杂度类型，建议自己看书的第17页表格**

> **2）线性数据结构：  代码**

代码主要关注： 线性表 - 顺序表 & 单链表 & 循环队列 **?后续整理的时候感觉是循环链表，但是你还是记得都复习一下**（看一下老师布置的题目！）

```
anyview list:

DC02PE33
比较两个有序顺序表的大小

DC02PE35
试写一算法，实现顺序表的就地逆置

DC02PE45
试写一算法，求并集A＝A∪B。

DC02PE71
实现带头结点单链表的判空操作。

DC02PE73
实现带头结点单链表的销毁操作

DC02PE75
实现带头结点单链表的清空操作

DC02PE77
实现带头结点单链表的求表长度操作

DC02PE82
在带头结点单链表L的第i个位置插入e。

DC02PE84
在带头结点单链表删除第i元素到e

DC02PE86
将带头结点单链表的第i元素起的所有元素移除，并构成一个带头结点的新链表。

DC02PE88
试写一算法，在带头结点单链表删除第i元素起的所有元素。

DC02PE90
删除带头结点单链表中所有值为x的元素

DC02PE91
删除带头结点单链表中所有值小于x的元素

DC02PE23
求循环队列的长度

DC02PE25
编写入队列和出队列的算法

DC02PE27
写出循环队列的入队列和出队列的算法

等等，我只是粗略整理了一下，具体还得靠你自己再整理
```
> 典型线性数据结构

1） 如果只允许在序列末端进行操作，这种线性结构称为栈

2） 如果只允许在序列两端进行操作，这种线性结构称为队列

3） 如果允许在序列任意位置进行操作，这种线性结构称为线性表

**线性结构的储存表示主要有两种：顺序存储 和 链式存储** P31

> 顺序栈 ：

采用顺序存储结构表示的栈称为顺序栈

栈的初始化操作时间复杂度 $O(1)$ ,

```c

Status InitStack_Sq(SqStack &S, int size, int inc) {
  S.elem = (ElemType*) malloc(size*sizeof(ElemType));
  if(NULL= == S.elem) return OVERFLOW;
  S.top = 0;
  S.size() = size;
  S.increment = inc;
  return OK;
}

```

栈的入队操作也为 $O(1)$，具体代码我不公示了，P34页、

```c

//most important:

ElemType *newbase;
if(S.top >= S.size())  //栈顶标位已到达所分配的容量，则栈满，扩容
{
  newbase = (ElemType*) realloc (S.elem, ((S.size + S.increment) * sizeof(ElemType)));
  if(NULL == newbase) return OVERFLOW;
  S.elem = newbase;
  S.size += S.increment;
}
S.elem[S.top ++] = e; // e入栈
return OK;

```

一些运用例子，比如进制转换 和 括号匹配序列等

> 循环队列 ：

循环队列是采用顺序存储结构的队列，需要按照队列可能的最大长度分配存储空间，其类型定义如下：

```c

typedef struct{
  ElemType *elem;
  int front;       //队头位标
  int rear;        //队尾位标
  int maxSize;     //存储容量
}SqQueue;

```

初始化队列时，令$Q.front = Q.rear = 0$； 出队时，队头位标 $Q.front$ 增 $1$ ；入队时，队尾位标 $Q.rear$ 增 $1$. 例子解释在书本P37。

**假溢出：**   由于出队在队头，入队在队尾，当 $Q.rear$ 等于 $Q.maxsize$ 时，若 $Q.front$ 不等于 $0$ ，则队列中其实还存在空闲单元，队列不是真满，这个时候如果还有入队操作，那么就会造成假溢出。

**循环队列：** 如果这个时候，我们将队列看成首尾相连的顺序队列，那么就可以称为循环队列，解决假溢出问题。

循环队列的入队实现公式:

$$Q.rear = (Q.rear + 1) \mod{Q.maxSize}$$

循环队列判断队满的公式：

$$Q.front == (Q.rear + 1) \mod{Q.maxSize}$$

实现过程，书本P38 - P40

> 顺序表 ：

采用顺序存储结构表示的线性表称为顺序表

? 平均查找长度怎么求 ASL-第二章43页

- 平均查找长度：

为确定元素位置，需要将表中的元素依次与给定值比较。查找成功时比较次数的期望值称为查找成功的**平均查找长度**，简称ASL。对于含有 $n$ 个元素的顺序表，查找成功的平均查找长度可表示为

$$
ASL_{\text{succ}} = \sum_{i=1}^{n} P_i \times C_i
$$

其中，顺序查找中的 $ASL = \frac{n + 1}{2}$ ;

因此，顺序查找的时间复杂度为 $O(n)$ ，**[ 成不成功都是O(n)，具体原因看时间复杂度计算 ]**

用顺序表实现的有序表成为有序顺序表 - 例题：P44 归并排序

**归并操作的时间复杂度和空间复杂度均为 $O(n)$**

> 链栈

采用链式存储结构的栈称为链栈，设栈 $S = (a_1, a_2, a_3, ... a_n)$ ，其中 $a_1$ 为栈底元素，$a_n$ 为栈顶元素，栈顶指针指向 $a_n$ ，当栈为空时，栈顶指针为 $NULL$ 。

具体实现过程 P53 - P55

> 链队列

控制队头队尾即可，具体实现P55 - P57

> 单链表

顺序表中进行插入和删除操作需要移动操作位置之后的元素，这种受限的存储结构显然难以满足更为广泛的需求，所以出现了一种能够快速在任意位置插入和删除元素的链式存储结构--链表，单链表就是其中的一种

单链表的一个结点对应一个元素，每个结点包括一个数据域和一个指针域，数据域存放元素的值，指针域存放直接后继结点的地址。

```c
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode,*LinkList;
```

自己去P57页了解： 头指针 表长 空表 首元结点

**单链表有不带头节点和带头节点的形式**

单链表的 查找 删除 插入 等 -> P58 - P63

循环链表 P66 - P68 **分为单循环链表和双循环链表**


> **3）排序基础： 考解答 - 直接插入排序 和 希尔排序 不怎么考代码**

> 直接插入排序：

直接插入排序的算法思想是，每次将无序区对的第一个记录按关键字插入到有序区的合适位置，并将有序区的长度加1。具体例子可以看书本P75

？ 什么是 **哨兵（Guard）**

其中，直接插入排序最坏情况时间复杂度为 $O(n^2)$ ， 但是直接插入排序只需要一个记录的辅助空间，空间复杂度为 $O(1)$

> 希尔排序

其实编写者非常鄙视希尔排序，所以把这个难题丢给你自己去看 P77 - P80

> 排序的稳定性

如果待排序记录中的关键字 $k(i = 1, 2, 3, ... ,n )$ 都不相同，则任何一个记录的无序序列经排序后得到的结果是唯一的；反之，若待排序的序列中存在两个或两个以上关键字相等的记录，则排序得到的结果不唯一。假设 $k_i = k_j (i != j)$ ，且在排序前的序列中 $k_i$ 领先于 $k_j$ （即 $i < j$）。若在排序后的序列中 $k_i$ 仍领先 $k_j$ ，则称该排序方法是稳定的，反之，若可能使排序后的序列中 $k_j$ 领先于 $k_i$ ，则称该排序方法是不稳定的。 

例子：P79

![](https://cdn.luogu.com.cn/upload/image_hosting/47iueobz.png)

> **4）哈希表： 开放定址法 链地址法**

> 直接定址法

一般情况下，开放定址法可通过对关键字缩放和平移，获得合适的地址区间，即以下线性函数:

$$ H(key) = a \times key + b $$

其中, $a$ 为缩放系数，$b$ 为平移系数。

```c
int hash_d(int key) {
  return a * key + b;
}
```

**注意，哈希冲突是不易避免的，关键在如何处理冲突**

> 链地址法

链地址法将关键字为同义词的记录链接在同一个单链表中。书本有例子解释P93

实现过程 书本P95-P97

> 开放定址法

**两种常用的开放定址法: 线性探测法和二次探测法**

实现过程 书本P97-P100

线性探测法的基本思想哈希函数是 

$$H_i = (H(k) + i) \bmod m,\ 1 \leq i \leq m-1$$

其中，$H_i$表示第 $i$ 次冲突时探测的地址空间。 例子P94

二次探测法基本思想哈希函数：
   
$$H_i = (H(k) + d_i ) \bmod m,\ 1 \leq i \leq m-1$$

其中， $d_i = 1^2 , -1^2 , 2^2 , -2^2 ,.... k^2, -k^2 (k <= m/2)$ 例子P94

**哈希查找的 $ASL$ :P101**

> **5）递归：归并 & 快排 & 广义表-递归定义的线性结构（必考?，因为老师没讲，弄懂深度 or 长度的定义含义）P125 T8 T9 过关**

> 折半查找

折半查找可以采用递归实现，其算法思路如下：

（1）设记录按关键字有序存储数组 $rcd[low..high]$ 中，待查找目标关键字为 $key$ 。如果 $high < low$，则序列为空，查找失败，结束；否则以中间位置 $mid = (low + high) / 2$ 为界，将 $rcd[low..high]$ 分成三个子序列：低半区  $rcd[low,,mid-1]$ ，中间关键字 $rcd[mid]$ ，和高半区 $rcd[mid+1..high]$。

（2）将 $rcd[mid]$ 与 $key$ 比较，产生了以下三个子问题：

a. 如果 $rcd[mid]$ 与 $key$ 相同，则查找成功，结束

b. 如果 $rcd[mid]$ 小于 $key$ ，则 $key$ 位于前半区，在 $rcd[low..mid-1]$ 内进行折半查找

c. 如果 $rcd[mid]$ 大于 $key$ ，则 $key$ 位于后半区，在 $rcd[mid+1..high]$ 内进行折半查找

在折半查找算法中，问题的解要么是其中一个子问题的解，要么无解，所以无须进行子解的组合。

> 归并排序

> 快速排序

> 广义表

  *长度：指的是元素个数，$(a , (a,b))$ -> 2
  *深度：圆括号嵌套的最大数目 $(a , (a,b))$ -> 2
  *表头：广义表中的第一个元素 $(a , (a,b))$ -> a
  *表尾：除了第一个元素的剩余元素组成的一个新广义表 $(a , (a,b), b)$ -> $( (a,b) , b)$
  $A = (a, (a,b))$ 尾表：$GetTail(A) = ( (a,b) )$ 这括号不能缺 不然吃零蛋吧你

**注意一下广义表的存储结构以及绘画方式P122**

> **6）二叉树：二叉树的遍历（most important!)**

  *二叉排序树的查找，插入（插入的新元素一定是叶子），删除（左子树右子树怎样咋的咋的）

> 二叉树

在书本P126-P127 至少了解什么是**左右分支，左右孩子，双亲，兄弟，度，分支节点，层次，深度，高度**

二叉树的性质：

1）在非空二叉树的第 $i$ 层上最多有 $2^{i-1}$ 个结点 $(i \ge 1)$

2）深度为 $k$ 的二叉树最多有 $2^k-1$ 个结点 $(k \ge 1)$

3）对于任意一颗二叉树，如果度为 $0$ 的结点个为 $n_o$ ，度为 $2$ 的个数为 $n_2$，则 $n_0 = n_2 + 1$。

**满二叉树：**

一棵深度为 $k$ 且有 $2^k-1$ 个结点的二叉树称为满二叉树。

**完全二叉树：**

约定从根开始，自上而下，自左而右，给满二叉树中的每个结点从 $1$ 到 $n$ 连续编号，编号为 $i$ 的结点可称为 $i$ 结点。深度为 $k$ 且含 $n$ 个结点的二叉树，如果其每个结点都与深度为 $k$  的满二叉树中编号从 $1$ 至 $n$ 的结点一一对应，则称为**完全二叉树**。P128有对应的完全二叉树和非完全二叉树的示例参考。

4）具有 $n$ 个结点的完全二叉树的深度 $k = \log(n)$ + 1 $ 其中 $log(n)$ 向下取整。

5）对于含 $n$ 个结点的完全二叉树中编号为 $i$ $(1 \le i \le n)$ 的结点

A. 如果 $i = 1$，则 $i$ 结点是这棵完全二叉树的根，没有双亲；否则其双亲编号为 $i/2$ 向下取整

B. 如果 $2i > n$，则 $i$ 结点没有左孩子；否则其左孩子编号为 $2i$。

C. 如果 $2i + 1 > n$，则 $i$ 结点没有右孩子；否则其右孩子编号为 $2i + 1$。

> **7）树：树的遍历（练习的那两题吃透了就稳了）**

  *逻辑树 转换 二叉树 形态
  *熟练地在树 二叉树 森林 上转换
  *B树（考代码）查找 插入 删除 （你们要背啊）

> 二叉树的遍历：

三种遍历顺序：**先序遍历，中序遍历，后序遍历**

1）中序遍历的算法步骤为，若二叉树不为空，则依次进行以下操作

a.遍历根节点的左子树

b.访问根节点

c.遍历根结点的右子树

其他遍历顺序可以看书本P133

![](https://cdn.luogu.com.cn/upload/image_hosting/70epdyvu.png)

> 堆

堆是一类完全二叉树，常用于实现排序，选择最小（大）值和优先队列等。

小顶堆：

$$ k_i \le k_{2i} , k_i \le k_{2i+1} $$

大顶堆：

$$ k_i \ge k_{2i} , k_i \ge k_{2i+1} $$

> 空树构成大根堆

从空树开始，依次插入关键字 $4、2、5、8、3、9$ ，构造大根堆。

插入 $4$ 后

```text
4
```

插入 $2$ 后，由于 $2$ < $4$， 不需要调整
 
```text
    4
   /
  2
```

插入 $5$ 后，原本插入的 $5$ 应该是 $4$ 的右孩子，但是 $5$ > $4$，交换 $5$ 和 $4$，调整为 $5$ 为根结点

```text
    5
   / \
  2   4
```

插入 $8$ 作为 $2$ 的左孩子，但 $8$ > $2$，交换 $8$ 和 $2$ ；然后 $8$ > $5$ ，交换 $8$ 和 $5$ ，调整后 $8$ 为根节点。

```text
    8
   / \
  5   4
 /
2
```
  
插入 $3$ 作为 $5$ 的右孩子，然后 $3$ < $5$ ，不需要进一步调整。

```text
    8
   / \
  5   4
 / \
2   3
```

插入 $9$ 后：

```text
    -9-
   /   \
  5     8
 / \   /
2   3 4
```

**在构建大根堆时，我们总是按照完全二叉树的顺序插入新节点，然后通过向上调整来维护堆性质**

> 堆排序

堆排序模拟过程 P147-P149 时间复杂度 $O(n\log{n})$ 。

> 二叉查找树

**二叉查找树**又称**二叉排序树**，或者是一颗空二叉树，又或者是具有如下特征的二叉树：

1）若左子树不空，则左子树上所有结点的值均小于根结点的值

2）若右子树不空，则右子树上所有结点的值均大于根结点的值

3）左、右子树也分别是二叉查找树

> 平衡二叉树

平衡二叉查找树又简称平衡二叉树。其中最出名的是**AVL树**。

平衡二叉树或者是棵空树，或者是具有下列性质的二叉查找树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度之差绝对值不超过 $1$ 。若将二叉树结点的平衡因子定义为该结点的左子树的高度减去它的右子树高度，则所有结点的平衡因子只可能为 $-1, 0, 1$。只要有一个结点的平衡因子的绝对值大于 $1$ ，那么这棵树就失去了平衡。

> **8）图：**

  *图的两种存储结构 和 遍历
  *深度优先遍历 & 广度优先遍历
  *邻接表 还原 图 or 图 还原 邻接表 手动分析 代码过关
  *最小生成树的 两种算法实现代码 普里姆算法 & 克鲁斯卡尔算法

>  图

图，分为**无向图**和**有向图**，具体定义看书本P189

W：需要了解的一些专有名词和相关定义 P190

1.子图

2.完全图

3.临接顶点

4.度、入度和出度

5.权和网

6.路径、简单路径和回路

7.连通图和强连通图

8.生成树

> 基于邻接矩阵的两种储存结构：邻接数组和邻接表

P192-P202

