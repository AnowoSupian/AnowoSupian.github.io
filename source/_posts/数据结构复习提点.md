---
title: 数据结构复习提点
date: 2025-11-09 12:47:15
tags: 期末考试 复习 数据结构
---

**Warning:** 你已经是一个合格的大学生了，要学会有自我主见和自我意识，遇到不会的或者不懂的准备提问的时候，先学习一下懂得**提问的智慧**

**考试时间：13周周四下午14点到16点**

### 试卷题目类型：

> **解答题**

课后练习的形式，例如输出排序结果

> **算法题**

$3$ 种形式

算法阅读，给定测试数据

书写代码含义，简洁的一句话左右：遍历？深度？

算法填空

> **算法设计（8分） -- 手写代码 写代码体**


1）单链表
2）二叉树

> **特别提示：平时成绩**

### 复习内容：

> **1）时间复杂度/频度： 简化的描述,注意书写形式**

定位书本Page: $13-18$

大部分情况下，单个表达式和语句的运行时间是常数，可认为与问题规模 $n$ 无关，记为 $O(1)$

一般情况下，通过找出执行次数最多的代码段，把它们的运行语句的总次数表示为 $n$ 的函数，就能确定算法的计算复杂度。对于并列循环结构，取各循环结构计算时间的最大值。对于嵌套循环结构，取最内层循环体中语句的执行次数。如果各层循环的次数是相互无关的，可简单采用乘法法则：各层循环的次数相乘

![](https://cdn.luogu.com.cn/upload/image_hosting/wjtag1ts.png)

**例题：**

Q1: 询问下面代码的时间复杂度：

```cpp
    void bubbleSort(int arr[], int n) {
    int i, j, temp;
    for (i = 0; i < n-1; i++) {
        for (j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```

A1: 这个时间复杂度是 $O((n) * (n-i))$，由于只需要求出它关于 $n$ 的增长率或阶即可。大 $O$ 符号可以简化圆括号内的公式，让其以最简单的形式表达算法的定性行为，因此，此题时间复杂度简化为 $O(n^2)$

**个人认为：需要懂得一些常见的复杂度类型，建议自己看书的第17页表格**

> **2）线性数据结构：  代码**

代码主要关注： 线性表 - 顺序表 & 单链表 & 循环队列 **?后续整理的时候感觉是循环链表，但是你还是记得都复习一下**（看一下老师布置的题目！）

```
anyview list:

DC02PE33
比较两个有序顺序表的大小

DC02PE35
试写一算法，实现顺序表的就地逆置

DC02PE45
试写一算法，求并集A＝A∪B。

DC02PE71
实现带头结点单链表的判空操作。

DC02PE73
实现带头结点单链表的销毁操作

DC02PE75
实现带头结点单链表的清空操作

DC02PE77
实现带头结点单链表的求表长度操作

DC02PE82
在带头结点单链表L的第i个位置插入e。

DC02PE84
在带头结点单链表删除第i元素到e

DC02PE86
将带头结点单链表的第i元素起的所有元素移除，并构成一个带头结点的新链表。

DC02PE88
试写一算法，在带头结点单链表删除第i元素起的所有元素。

DC02PE90
删除带头结点单链表中所有值为x的元素

DC02PE91
删除带头结点单链表中所有值小于x的元素

DC02PE23
求循环队列的长度

DC02PE25
编写入队列和出队列的算法

DC02PE27
写出循环队列的入队列和出队列的算法

等等，我只是粗略整理了一下，具体还得靠你自己再整理
```

> 顺序表 ：

采用顺序存储结构表示的线性表称为顺序表

? 平均查找长度怎么求 ASL-第二章43页

- 平均查找长度：

为确定元素位置，需要将表中的元素依次与给定值比较。查找成功时比较次数的期望值称为查找成功的**平均查找长度**，简称ASL。对于含有 $n$ 个元素的顺序表，查找成功的平均查找长度可表示为

$$
ASL_{\text{succ}} = \sum_{i=1}^{n} P_i \times C_i
$$

其中，顺序查找中的 $ASL = \frac{n + 1}{2}$ ;

因此，顺序查找的时间复杂度为 $O(n)$ ，**[ 成不成功都是O(n)，具体原因看时间复杂度计算 ]**

用顺序表实现的有序表成为有序顺序表 - 例题：P44 归并排序


> 单链表

顺序表中进行插入和删除操作需要移动操作位置之后的元素，这种受限的存储结构显然难以满足更为广泛的需求，所以出现了一种能够快速在任意位置插入和删除元素的链式存储结构--链表，单链表就是其中的一种

单链表的一个结点对应一个元素，每个结点包括一个数据域和一个指针域，数据域存放元素的值，指针域存放直接后继结点的地址。

```c
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode,*LinkList;
```

自己去P57页了解： 头指针 表长 空表 首元结点

**单链表有不带头节点和带头节点的形式**

单链表的 查找 删除 插入 等 -> P58 - P63

循环链表 P66 - P68 **分为单循环链表和双循环链表**


> **3）排序基础： 考解答 - 直接插入排序 和 希尔排序 不怎么考代码**

> 直接插入排序：

直接插入排序的算法思想是，每次将无序区对的第一个记录按关键字插入到有序区的合适位置，并将有序区的长度加1。具体例子可以看书本P75

？ 什么是 **哨兵（Guard）**

其中，直接插入排序最坏情况时间复杂度为 $O(n^2)$ ， 但是直接插入排序只需要一个记录的辅助空间，空间复杂度为 $O(1)$

> 希尔排序

其实编写者非常鄙视希尔排序，所以把这个难题丢给你自己去看 P77 - P80

> **4）哈希表： 开放定址法 链地址法**

> 直接定址法

一般情况下，开放定址法可通过对关键字缩放和平移，获得合适的地址区间，即以下线性函数:

$$ H(key) = a \times key + b $$

其中, $a$ 为缩放系数，$b$ 为平移系数。

```c
int hash_d(int key) {
  return a * key + b;
}
```

**注意，哈希冲突是不易避免的，关键在如何处理冲突**

> 链地址法

链地址法将关键字为同义词的记录链接在同一个单链表中。书本有例子解释P93

> 开放定址法

**两种常用的开放定址法: 线性探测法和二次探测法**

线性探测法的基本思想哈希函数是

$$H_i = (H(k) + i) \bmod m,\ 1 \leq i \leq m-1$$

其中，$H_i$表示第 $i$ 次冲突时探测的地址空间。 例子P94

二次探测法基本思想哈希函数：

$$H_i = (H(k) + d_i ) \bmod m,\ 1 \leq i \leq m-1$$

其中， $d_i = 1^2 , -1^2 , 2^2 , -2^2 ,.... k^2, -k^2 (k <= m/2)$ 例子P94

> **5）递归：归并 & 快排 & 广义表-递归定义的线性结构（必考?，因为老师没讲，弄懂深度 or 长度的定义含义）P125 T8 T9 过关**

  *长度：指的是元素个数，$(a , (a,b))$ -> 2
  *深度：圆括号嵌套的最大数目 $(a , (a,b))$ -> 2
  *表头：广义表中的第一个元素 $(a , (a,b))$ -> a
  *表尾：除了第一个元素的剩余元素组成的一个新广义表 $(a , (a,b), b)$ -> $( (a,b) , b)$
  $A = (a, (a,b))$ 尾表：$GetTail(A) = ( (a,b) )$ 这括号不能缺 不然吃零蛋吧你

> **6）二叉树：二叉树的遍历（most important!)**

  *二叉排序树的查找，插入（插入的新元素一定是叶子），删除（左子树右子树怎样咋的咋的）

> **7）树：树的遍历（练习的那两题吃透了就稳了）**

  *逻辑树 转换 二叉树 形态
  *熟练地在树 二叉树 森林 上转换
  *B树（考代码）查找 插入 删除 （你们要背啊）

> **8）图：**

  *图的两种存储结构 和 遍历
  *深度优先遍历 & 广度优先遍历
  *邻接表 还原 图 or 图 还原 邻接表 手动分析 代码过关
  *最小生成树的 两种算法实现代码 普里姆算法 & 克鲁斯卡尔算法
