---
title: 二分图
date: 2025-08-26 11:05:39
tags:
---

### 二分图学习笔记

也是狠狠学到了二分图了

> 二分图是啥？

二分图，又称二部图，是一类结构特殊的图。它的顶点集可以划分为两个互不相交的子集，使得图中的每条边都连接这两个集合之间的一对点，而不会连接同一集合内部的点。    --oi wiki

额，我一开始也没读懂，找了一些资料，给了这样一张图，那我们也就用这个图分析吧

![](https://cdn.luogu.com.cn/upload/image_hosting/cmz56tqt.png)

也就是说，将所有的点分为两个集合，集合内部的点之间没有直接路径，也就是说，**边只会连接两个集合**

>二分图判定

~~暴力的话是可以的（）~~

可以贪心地跑(?)，毕竟与$u$连接的所有点$v$都不可能与$u$属于同一个集合

所以相当于染色，$u$是黑色，与$u$连接的所有点$v$都被染成白色，如果与$u$连接的点$v$存在黑色的，那么就不是二分图

所以因此我们也能知道，二分图内部不存在奇数边的环

>二分图匹配

**匹配：在图论中，一个匹配是指在边的集合内部，任意两条边都没有公共集合**

例如：这个就是匹配:

![](https://s1.ax1x.com/2020/03/29/GZHaVK.png)

这个就不是匹配：
![](https://s1.ax1x.com/2020/03/29/GZbZJe.png)

这种图太多了，于是恶心人的东西出现了

[P3386 【模板】二分图最大匹配](https://www.luogu.com.cn/problem/P3386)

>匈牙利算法

啊，这个其实我自己感觉怪怪的，但是又觉得蛮合理的？(bushi)

和deepseek玩了两三天得出来的大致规律

就是假设初始匹配是 $u1-v1$, $u2-v2$, $u3-v3$（已经是完美匹配）。现在引入一个新的左边点 $u4$，它只连接 $v1$ 和 $v2$。

$u4$ 尝试匹配 $v1$ -> 发现被 $u1$ 占了 -> 递归问 $u1$：“你能换一个吗？”

$u1$ 尝试它的其他边（比如 $v3$）-> 发现 $v3$ 被 $u3$ 占了 -> 递归问 $u3$：“你能换一个吗？”

$u3$ 尝试它的其他边 -> 发现没有其他边了！$u3$ 的DFS失败。

$u1$ 得知 $u3$ 无法让出 $v3$，于是 $u1$ 尝试自己的下一个边（如果没有了，也失败）。

$u4$ 得知 $u1$ 无法让出 $v1$，于是 $u4$ 尝试自己的下一个目标 $v2$。

$u4$ 尝试匹配 $v2$ -> 发现被 $u2$ 占了 -> 递归问 $u2$：“你能换一个吗？”

$u2$ 尝试它的其他边 -> 发现没有其他边了！$u2$ 的DFS失败。

$u4$ 得知 $u2$ 也无法让出 $v2$，并且自己也没有其他边可试了。最终，$u4$ 的DFS失败，无法为它找到匹配。

这个过程就像是在进行一场连锁谈判：

$u4$ 对 $u1$ 说：“你把 $v1$ 让给我吧。”

$u1$ 对 $u3$ 说：“那你把 $v3$ 让给我，我就能把 $v1$ 让给 $u4$ 了。”

$u3$ 说：“我无处可去，让不了。”

谈判破裂。$u4$ 又去找 $u2$ 谈判，同样失败。

最后查询所有match[$vi$] != 1的个数就行啦

Accepted标程：

```cpp

//P3386 【模板】二分图最大匹配
#include <iostream>
#include <vector>
#define endl '\n'
#define ll long long
using namespace std;
ll n,m,e;

vector<ll> V[50010];


bool ask(ll u, vector<ll> &vis,vector<ll> &Match){
    for(int i=0; i<V[u].size(); i++){
        if(vis[V[u][i]]) continue;

        vis[V[u][i]] = 1;
        if(Match[V[u][i]] == -1 || ask(Match[V[u][i]],vis,Match) ){
            Match[V[u][i]] = u;
            return true;
        }
    }
    return false;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);

    cin>> n >> m >> e;

    vector<ll> Match(m+5,-1);

    for(int i=1; i<=e; i++){
        ll l,r;
        cin>>l >> r;
        V[l].push_back(r);
    }
    for(int i=1; i<=n; i++){
        vector<ll> vis(m+5,0);
        for(int r=0; r<V[i].size(); r++){

            if(Match[V[i][r]] == -1 || ask(Match[V[i][r]],vis,Match) )
            {
                Match[V[i][r]] = i;  //标记他是与i连接的
                break;
            }
        }
    }
    ll ans = 0;
    for(int i=1; i<=m; i++) if(Match[i] > 0) ans ++;
    cout<<ans<<endl;
    return 0;
}

```

