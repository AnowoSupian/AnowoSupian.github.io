---
title: P1525 [NOIP 2010 提高组] 关押罪犯 题解解析
date: 2025-08-30 15:41:23
tags: 题解
---

>题目

[P1525 [NOIP 2010 提高组] 关押罪犯](https://www.luogu.com.cn/problem/P1525)

这个题目，额，很典型，所以用来收集了

比较有意思，这题是我在学二分图的时候给的一个例题，但是这题有两个做法，两个做法都是非常典的题型

>二分图法

我们其实很容易知道，如果这个图呢，他是二分图的话，那么答案一定是$0$，对吧

但如果不是二分图呢？ 那怎么办，我们是不是可以考虑删除一些边使得它成为二分图啊，但是删除边代表什么意思

如果删除边的话，就代表我们不得不让这两个互相有怨恨的人在一起了，so bad

那我们肯定希望能删除的边的边权（怨恨值）尽可能小吧

那我们是不是可以从大到小排序？往下看到哪个开始删除才能使得成为二分图？对吧，你想想

从大到小开始的话，如果我删除了边$a_i$,那么对于边$a_{i+1}$,$a_{i+2}$...我都可以删掉，但是我要什么？我要的是最小，所以当前如果我删除这个边能成为一个二分图，那么这个权值就是答案，每往下走一次，如果能够构成一次二分图，答案就更新一次，如此所做

但是。。。这个时间复杂度是$O(NM)$的

那我们要考虑优化，真的要走一遍$M$吗，能不能更快定位到那个才能满足答案

其实很快我们就发现，如果对于一个删除边权的大小$x$，如果$x$是满足条件的，那么我们就要考虑小于$x$的数值，这个听起来就很？ 二分

那么二分的上下界只差为$C_i$，最大为$10^9$，那么时间复杂度可以立刻变成$O(log1E9 * N)$

证毕

Accepted代码:
```cpp

//P1525 
#include <iostream>
#include <algorithm>
#include <vector>
#define ll long long
using namespace std;

ll n,m;
ll Max;
bool fal;
vector<ll> vis(200005,0);
vector<ll> col(200005,0);

struct point{
    ll u;
    ll v;
    ll c;
}p[200010];

struct Point{
    ll v;
    ll c;
};

vector<Point> V[200010];

void dfs(ll x,ll point, ll dist){

    if(fal) return ;

    if(vis[x]) return ;
    
    if(!vis[x]) col[x] = point;

    vis[x] = 1;
    
    for(int r=0; r<V[x].size(); r++){
         
        if(V[x][r].c <= dist) continue;
        // cerr<<"c:"<<V[x][r].c<<endl;

        if(!vis[V[x][r].v]){

            dfs(V[x][r].v,point+1,dist);
        }
        else {
            if( (col[V[x][r].v] % 2) == (point % 2) )
            {
                fal = 1;
                return ;
            }
        }
    }
}

bool judge(ll x){
    //dfs跑图
    for(int i=1; i<=n; i++){
        if(vis[i]) continue;

        fal = 0;

        dfs(i,0,x);
        if(fal) return false;
    }
    return true;
}

ll check(){
    ll l = 0, r = 1E9, ans = r;
    while(l <= r) {
        
        ll mid = (l + r) / 2;

        for(int i=1; i<=n; i++) vis[i] = 0, col[i] = 0;

        if (judge(mid)) {

            r = mid - 1;
            ans = mid;
            
        } else {

            l = mid + 1;

        }
        // cerr<<ans<<endl;
    }
    
    return ans;
}

int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);


    cin>>n>>m;
    
    for(int i=1; i<=m; i++){
        cin>>p[i].u>>p[i].v>>p[i].c;
        Max = max(Max,p[i].c);
        V[p[i].u].push_back({p[i].v,p[i].c});
        V[p[i].v].push_back({p[i].u,p[i].c});
    } 

    cout<<check()<<endl;
    
    return 0;
}

```