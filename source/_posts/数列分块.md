---
title: 数列分块
date: 2025-09-12 18:41:05
tags: 算法
---

> 数列分块入门 8

Problem [link](https://www.luogu.com.cn/problem/P13983)

其实我真的不会证明这题的时间复杂度说实话，但是因为他是覆盖性的，所以时间复杂度就可以缩到nsqrt(n)？

```cpp
//P13983 
#include <iostream>
#include <cmath>
#include <vector>
#define ll long long
#define endl '\n'
using namespace std;
const ll INF = 2147483648+1;
ll a[300010],n;
ll L[300010],R[300010],Belong[300010],F[300010];
vector<ll> p(300010,INF); //记录每个块的颜色，2147483648表示不统一
void init(){
    ll len = sqrt(n);
    ll tot = (n-1)/len + 1;
    for(int i=1; i<=tot; i++){
        L[i] = (i-1)*len + 1;
        R[i] = i*len;
    } R[tot] = n;
    for(int i=1; i<=tot; i++){
        for(int j=L[i]; j<=R[i]; j++){
            Belong[j] = i;
            if(a[j] != a[L[i]]) F[i] = 1; //标记这个块内颜色其实并不是均匀分配的
        }
        // cerr<<"F"<<i<<' '<<F[i]<<endl;
        if(! F[i])  //块内颜色全是一种的
        p[i] = a[L[i]];
    }
}
ll Find(ll l, ll r, ll c){
    ll Lf = Belong[l], Rf = Belong[r];
    ll ans = 0;
    if(Lf == Rf){ //在同一块内
        if(!F[Lf] && p[Lf] != c) return 0; //块内颜色均匀且与c不同
        for(int i=L[Lf]; i<=R[Lf]; i++){
            if(p[Lf] != INF) a[i] = p[Lf];
        } p[Lf] = INF;
        F[Lf] = 1;
        for(int i=l; i<=r; i++){
            
            if(a[i] == c) ans++;
        }
        return ans;
    }

    // 不在同一块内
    // cerr<<"L"<<endl;
    // cerr<<F[Lf]<<' '<<p[Lf]<<endl;
    if(!F[Lf] && p[Lf] != c) ans += 0; //块内颜色均匀且与c不同
    else{
        for(int i=L[Lf]; i<=R[Lf]; i++){
            if(p[Lf] != INF) a[i] = p[Lf];
        }
        p[Lf] = INF;
        F[Lf] = 1;
        for(int i=l; i<=R[Lf]; i++){
            // cerr<<a[i]<<' ';
            if(a[i] == c ) ans++;
        }
        
    }
    // cerr<<endl;
    // cerr<<"R"<<endl;
    // cerr<<F[Rf]<<' '<<p[Rf]<<endl;
    if(!F[Rf] && p[Rf] != c) ans += 0; //块内颜色均匀且与c不同
    else{
        for(int i=L[Rf]; i<=R[Rf]; i++){
            if(p[Rf] != INF) a[i] = p[Rf];
        } p[Rf] = INF;
        F[Rf] = 1;
        for(int i=L[Rf]; i<=r; i++){
            // cerr<<a[i]<<' ';
            if(a[i] == c ) ans++;
        }
    }
    // cerr<<endl;
    // cerr<<"M"<<endl;
    for(int i=Lf+1; i<=Rf-1; i++){
        if(!F[i]){ //块内颜色均匀
            if(p[i] == c) ans += (R[i]-L[i]+1);
            // cerr<<"same of c:"<<c<<endl;
        }
        else{
            for(int j=L[i]; j<=R[i]; j++){
                if(p[i] != INF) a[j] = p[i];
            }
            p[i] = INF;
            F[i] = 1;

            for(int j=L[i]; j<=R[i]; j++){
                // cerr<<a[j]<<' ';
                if(a[j] == c) ans++;
            }
        }
    }
    // cerr<<endl;
    return ans;

}
void Fixed(ll l,ll r,ll c) {
    ll Lf = Belong[l], Rf = Belong[r];
    if (Lf == Rf) { //在同一块内
        for (int i = L[Lf]; i <= R[Lf]; i++) {
            if(p[Lf] != INF) a[i] = p[Lf];
        }

        for (int i = l; i <= r; i++) {
            a[i] = c;
        }
        p[Lf] = INF;
        F[Lf] = 1;
        return;
    }

    for (int i = L[Lf]; i <= R[Lf]; i++) {
        if(p[Lf] != INF) a[i] = p[Lf];
    }

    for (int i = l; i <= R[Lf]; i++) {
        a[i] = c;
    }

    p[Lf] = INF;
    F[Lf] = 1;

    for (int i = L[Rf]; i <= R[Rf]; i++) {
        if(p[Rf] != INF) a[i] = p[Rf];
        // a[i] = a[i];
    }

    for (int i = L[Rf]; i <= r; i++) {
        a[i] = c;
    }

    p[Rf] = INF;
    F[Rf] = 1;

    for (int i = Lf + 1; i <= Rf - 1; i++) {
        p[i] = c;
        F[i] = 0;
    }

}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>> n;

    for(int i=1; i<=n; i++){
        cin>>a[i];
    }
    init();

    // for(int i=1; i<=n; i++) cerr<<F[i]<<" ";
    // cerr<<endl;

    for(int i=1; i<=n; i++){
        // cerr<<"Now is : "<<i<<endl;

        ll l,r,c;
        cin>>l>>r>>c;
        ll ans = Find(l,r,c);
        Fixed(l,r,c);
        cout<<ans<<endl;
    }
    return 0;
}

```

