---
title: 莫队算法
date: 2025-08-10 13:07:49
tags:
---

<!-- {% katex %} E = mc^2 {% endkatex %} -->

### 简单询问莫队

其实一开始做数据结构的时候，我就想过，能不能像滑动窗口一样，从已知区间答案推导到另一个区间

不过那个时候想的是O(N^2)的思路，如今，莫队，用一个更好的暴力的时间复杂度证明了，这种方法是可行的

我们可以按照**l,r的关键字**排序，即对于区间[l,r]，以 l 所在块的编号为第一关键字，r 为第二关键字从小到大排序。

**时间复杂度解释:**

![](https://cdn.luogu.com.cn/upload/image_hosting/b80mkc2o.png)

图1是按照x从小到大排序，也就是我们初学的时候想的思路，震荡幅度足够大时，可能达到O(N^2)

图2时莫队算法排序后的路径，以x轴分成多个块，每个块按照y坐标排序，那么y的幅度最大为块长，时间复杂度可以降到O(N * sqrt(N)) 设定块长为sqrt(n)，带修莫队的话，建议上到pow(N,2.0/3.0)

![](https://cdn.luogu.com.cn/upload/image_hosting/oqdz6zyg.png)

```cpp
while(l > q[i].l) add(a[--l]);
while(r < q[i].r) add(a[++r]);
while(l < q[i].l) del(a[l++]);
while(r > q[i].r) del(a[r--]);
```

这些区间的位置，我们都可以通过O(1)方式获得

例题:[P2709 小B的询问](https://www.luogu.com.cn/problem/P2709)

```cpp
//P2709
#include <iostream>
#include <cmath>
#include <algorithm>
#define ll long long
using namespace std;
ll B,n,m,k,ans;
ll a[50010];
ll K[50010];
ll Ans[50010];

struct Q{
    ll l;
    ll r;
    ll i;
}q[50010];

bool cmp(Q a,Q b){
    if(a.l/B != b.l/B) return a.l < b.l;
    return a.r < b.r;
}
void add(ll x){
    ans += 2*K[x] + 1;
    K[x] ++;
}
void del(ll x){
    ans += -2*K[x] + 1;
    K[x] --;
}

int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    
    cin>>n>>m>>k;
    B = sqrt(n); //块长

    for(int i=1; i<=n; i++) cin>>a[i];

    for(int i=1; i<=m; i++){
        cin>>q[i].l>>q[i].r;
        q[i].i = i;
    }

    sort(q + 1, q + 1 + m, cmp);

    // for(int i=1; i<=m; i++){
    //     cerr<<q[i].l<<" "<<q[i].r<<" "<<q[i].i<<endl;
    // }

    for(int i = 1, l = 1, r = 0; i <= m; i ++){
        while(l > q[i].l) add(a[--l]);
        while(r < q[i].r) add(a[++r]);
        while(l < q[i].l) del(a[l++]);
        while(r > q[i].r) del(a[r--]);
        Ans[q[i].i] = ans;
        // cerr<<ans<<endl;
    }
    for(int i = 1; i <= m; i++) cout<<Ans[i]<<endl;
    return 0;
}
```